# 2.2web和HTTP

### 2.2.1 HTTP概况

> 1. Web的应用协议是**超文本传输协议(HTTP)**。
>
>    > - HTTP由两个程序实现：一个客户端程序和一个服务器程序。
>    >- 二者运行在不同的端系统中，通过**HTTP报文**进行会话。
>    > - HTTP定义了**报文的结构**以及客户和服务器进行**报文交换的方式**。
>    
> 2. **Web页面**是由**对象**组成的
>
>    > - 一个**对象**只是一个**文件**，诸如一个HTML文件、一个JPEG图形，且它们可通过一个**URL地址寻址**。
>   > - 多数页面含有一个**HTML基本文件**以及几个引用对象，如果一个Web页面含有HTML文件和5个JPEG图形，那么这个Web页面有6个对象。
>    > - HTML基本文件通过**URL**进行**引用页面中的其他对象**。每个URL由**两部分**组成：**存放对象的服务器主机名**和**对象的路径名**。
>    > - **Web浏览器**实现了HTTP的客户端。
>    > - **Web服务器**实现了HTTP的服务器端。
>
> 3. HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。
>
> 4. HTTP使用**TCP**作为它的支撑**运输协议**。
>
>    > - HTTP客户首先**发起**一个与服务器的**TCP连接**，一旦连接建立，该浏览器和服务器进程就可以通过**套接字接口**访问TCP。
>   > - （由于使用了TCP协议）一个客户进程发出的每个HTTP请求报文最终能**完整**的到达服务器，反之（响应报文）亦然。
>    > - 由于**协议分层**，HTTP协议**不担心数据丢失**，也**不关心运输细节**。
>
> 5. HTTP是一个**无状态协议**
>
>    > - HTTP服务器不保存客户的任何信息
>    > - 由于不保存客户的任何信息，所以如果同一个客户在短时间请求同一个对象多次，服务器不会因为刚刚为客户提供了该对象就不再做出反应，而是会重新发送该对象。



****

### 2.2.2 非持续连接和持续连接

> 1. 客户会对服务器发送一系列请求，并且服务器对每个请求进行相应。这些请求可能以规则的间断周期性的或间断无周期的一个接一个发出。
> 2. 由于客户-服务器交互是使用TCP进行的，应用程序的研发者就需要做出一个决定：每个请求/响应对是经过**一个单独的TCP连接**发送；还是所有请求及响应经过**相同的TCP连接**发送。
>    采用一种方法的话，该应用程序被称为使用**非持续连接**，
>    采用后一种方法的话，该应用程序被称为使用**持续连接**
> 3. HTTP**默认情况**下是使用**持续连接**，HTTP客户和服务器也能配置成使用非持续连接



1. **采用非持续连接的HTTP**

> - 传送Web页面
>   - 在**非持续连接**下，从服务器向客户传送一个Web页面的步骤：
>     假设该web页面有一个HTML基本文件和10JPEG图形（或其他服务器资源），并且这11个对象位于同一台服务器上，进一步假设该HTML文件的URL为：`https://www.someSchool.edu/someDepartment/home.index`.
>
>     > 1）HTTP客户进程在**端口号80**发起一个到服务器`www.someSchool.edu`的TCP连接。80端口为HTTP的默认端口。在客户和服务器上分别由一个套接字与该连接相关联
>     >
>     > 2）HTTP客户经它的**套接字**向该服务器发送一个**HTTP请求报文**。请求报文中包含**路径名**`/someDepartment/home.index`。
>     >
>     > 3）HTTP服务器进程经它的套接字接收该请求报文，从其存储器（RAM或磁盘）检索出对象`https://www.someSchool.edu/someDepartment/home.index`，在一个**HTTP响应报文**中**封装对象**，并通过其套接字向客户发送响应报文。
>     >
>     > 4）HTTP服务器进程**通知**（只是通知！）TCP断开该TCP连接。（但直到TCP确认客户已经收到响应报文为止，它才会实际中断连接）
>     >
>     > 5）HTTP客户**接收响应报文**，**TCP连接关闭**。该报文指出封装对象是一个HTML文件，客户从响应报文中提取出该文件，**检查该HTML文件**，**得到10个**JPEG图形（或其他服务器资源）的**引用**。
>     >
>     > 6）对每个引用的JPEG图形对象（或其他服务器资源）重复前4个步骤
>
>   - 当浏览器收到Web界面后，向用户显示该页面。两个不同的浏览器也许会以不同的方式解释页面。但浏览器如何向客户解释一个Web页面与HTTP毫无关系。HTTP规范（`[RFC 1948]`、`[RFC 2616]`）**仅定义了**在HTTP客户程序与HTTP服务器程序之间的**通信协议**。
>
>   - 上述的步骤举例说明了**非持续连接**的使用，其中每个TCP连接在服务器发送**一个对象**后**关闭**，即该连接并**不为其他的对象而持续下来**。值得注意的是**，每个TCP连接**只**传输一个请求报文和一个响应报文**。因此在本例中，当用户请求该Web页面时，要产生11个TCP连接。
>
>   - 在上述步骤中，没有明确客户获得这10个JPEG图形（或其他服务器资源）对象是使用了10个**串行的TCP连接**还是某些对象使用了**并行的TCP连接**，在默认情况下，大部分浏览器打开5-10并行的TCP连接，而每条连接处理一个**请求响应事务**。
>
> 
>
> - **往返时间**
>
>   - 为了简单的估算一下从客户请求HTML基本文件起到该客户收到整个文件所花费的时间，我们定义**往返时间**即**RTT**
>
>     > 1. RTT：该时间指一个短分组从客户到服务器然后再返回客户所花费的时间。
>     > 2. RTT包括**分组传播时延**、**排队时延**、**处理时延**。
>
>   - **三次握手**：当用户点击超链接，引起浏览器和Web服务器之间发起一个**TCP连接**，涉及一个三次握手过程
>
>     > 1. 三次握手过程：客户向服务器发送一个小TCP报文段；服务器用一个小TCP报文段做出确认和响应；最后客户向服务器返回确认。
>     > 2. 三次握手**前两个部分**所耗费的时间占用了**一个RTT**。
>     > 3. 完成三次握手的前两个部分以后，客户结合三次握手的**第三部分（确认）**向该TCP连接发送一个**HTTP请求报文**，一旦该请求报文到达服务器，服务器就在该**TCP连接**上发送**HTML文件**。该**HTTP请求/响应**用去了**另一个RTT**。
>     > 4. 粗略的说，**总的响应时间**就是**两个RTT**加上**服务器传输HTML文件的时间**。



2. **采用持续连接的HTTP**

   > - 非持续连接的缺点
   >
   >   > 1. 必须为每一个请求的对象建立和维护一个全新的连接，对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，这给Web服务器带来了严重的负担，因为一台Web服务器可能同时服务于数以百计不同的客户的请求。
   >   > 2. 每一个对象经受两倍RTT的交付时延，即一个RTT用于创建TCP，另一个RTT用于请求和接收一个对象。
   >
   > - 持续连接的介绍
   >
   >   > 1. 服务器在发送响应后保持该TCP连接打开。在相同的客户与服务器之间，后续的请求和响应报文能够通过相同的连接进行传送。（特别是一个完整的Web页面，甚至是多个Web页面，可以用单个持续的TCP连接进行传送）客户对对象资源的请求可以一个接一个的发出，而不必等待对未决请求（流水线）的回答。
   >   >
   >   >    > Q：此处*不必等待对未决请求（流水线）的回答*的意思是什么？
   >   >    >
   >   >    > A：此处应该是和非持续连接进行对比：
   >   >    >
   >   >    > I. 在持续连接中，由于HTTP默认模式是使用带流水线的持续连接，此处说的是在流水线上，即使前面发送的一个请求可能由于网络问题或其他原因而导致HTTP服务器响应时间较长，但不影响后面一个请求的发起。
   >   >    >
   >   >    > II. 在非持续连接中，（如果最大并行的TCP数量为1的话）假设第一个请求响应时间较长，那么客户发起第二个请求之前必须等待HTTP服务器对第一个请求（即未决请求）的回答。
   >   >    >
   >   >    > （顺便吐槽一下自顶向下第七版的翻译，，很多名词的介绍还没出现就直接使用了，比如上文的流水线在下面才提到（上面看流水线三个字看得都快不认识了还没是没搞懂这个比喻是什么意思。。。）还有 有部分的翻译语句总觉得很奇怪。。。不过翻译确实很辛苦！！我也只是吐槽一下！！）
   >   >
   >   > 2. 一般来说，如果一条连接经过一定时间间隔（可配置）仍未被使用，HTTP服务器就关闭该连接。HTTP的默认模式是使用带流水线的持续连接。
   >   >
   >   > 3. HTTP/2[RFC 7540]是在HTTP1.1的基础上构建的，它允许在相同连接中的多个请求和回答交错。



****

### 2.2.3 HTTP报文格式

> 1. HTTP规范[RFC 1945; RFC 2616; RFC 7540]包含了对HTTP报文格式的定义。HTTP报文有两种：请求报文和响应报文。



1. HTTP请求报文

   > - HTTP请求报文示例：
   >
   >   > ```http
   >   > GET /somedir/page.html HTTP/1.1
   >   > Host :  www.someschool.com
   >   > Connection: close
   >   > User-agent：Mozilla/5.0
   >   > Accept-language :  fr
   >   > ```
   >   
   > - 报文分析
   >
   >   > 1. 该文本是用普通的**ASCII文本**书写的。一个请求报文能有更多行或至少一行
   >   >
   >   > 2. HTTP请求报文的第一行叫做**请求行**
   >   >
   >   >    > - 请求行的三个字段：**方法字段**、**URL字段**、**HTTP版本字段**
   >   >    > - 方法字段取值：GET、POST、HEAD、PUT、DELETE
   >   >
   >   > 3. 其后继的行叫做**首部行**
   >   >
   >   >    > - **Host**：指明对象所在的主机，用于Web代理高速缓存
   >   >    >
   >   >    > - **Connection**：close 使用非持续连接，它要求服务区发送完被请求的对象后就关闭这条连接。
   >   >    >
   >   >    > - **User-agent**：用来指明用户代理，即**浏览器类型**。Mozilla/5.0指的是Firefox浏览器。
   >   >    
   >   > 4. 在首部行下面有一个**实体体**
   >   >
   >   >    > - 当使用GET请求时，实体体为空
   >   >    > - GET方法使用 `URL ? 参数`  的形式
   >   >    > - 当使用POST请求时才使用该实体体
   >   >    > - 实体体包含表单提交的参数
   >   >
   >   > 5. 其他方法
   >   >
   >   >    > - **HEAD**方法类似GET方法。当服务器接收到一个使用HEAD方法的请求时，将会用一个HTTP报文进行响应，但是并**不返回请求对象**。
   >   >    > - **PUT**方法允许用户上传对象到指定的Web服务器上指定的路径，
   >   >    > - **DELETE**方法允许用户或应用程序删除Web服务器上的对象

   

2. HTTP响应报文

   > - HTTP响应报文示例
   >
   >   > ```http
   >   > HTTP/1.1 200 ok
   >   > Connection:  close
   >   > Date: Tue, 18 Aug 2015 15:44:04 GMT
   >   > Server: Apache/2.2.3(CentOS)
   >   > Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
   >   > Content-Length: 6821
   >   > Content-Type: text/html
   >   > ....(data)
   >   > ```
   >
   > - 报文分析
   >
   >   > 1. 初始**状态行**
   >   >
   >   >    > - 状态行的3个字段：协议版本字段、状态码、相应状态信息
   >   >    >
   >   >    > - 在这个例子中，状态行指示服务器正在使用HTTP/1.1，并且一切正常。
   >   >    >
   >   >    > - 常见状态码
   >   >    >
   >   >    >   > - 200 OK : 请求成功
   >   >    >   > - 301 Moved Permanently：请求的对象已经被永久转移了
   >   >    >   > - 400 Bad Requst：该请求不能被服务器理解
   >   >    >   > - 404 Not Found：被请求的文档不在服务器上
   >   >    >   > - 505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP版本协议 
   >   >
   >   > 2. 首部行
   >   >
   >   >    > - Connection:  close 告诉客户，发送完报文后将关闭该TCP连接。
   >   >    >
   >   >    > - Date：服务器产生并发送该响应报文的日期和时间，该时间指的是：服务器从它的文件系统中检索到该对象，将该对象插入响应报文，并发送该响应报文的时间。
   >   >    >
   >   >    >   > Q：所以这个时间是哪个时间（时刻）
   >   >    >   >
   >   >    >   > A：记录在Date上的时刻应该是**发送响应报文的时刻**
   >   >    >   >       其实我个人感觉上面这一大段解释基本没啥意义，越讲越乱。
   >   >    >
   >   >    > - Server:指示报文由什么服务器产生的
   >   >    >
   >   >    > - Last-Modified: 对象创建或最后修改的时间
   >   >    >
   >   >    > - Content-Length: 被发送对象中的字节数
   >   >    >
   >   >    > - Content-Type: text/html 表明实体体中的对象是HTML文本



****

### 2.2.4 用户与服务器的交互：cookie

> 1. cookie在[RFC 6265]中定义它允许站点**对用户进行追踪**。它能确切的知道用户按照什么顺序、在什么时间访问了哪些页面。
>
> 2. cookie技术有**四个组件**：
>
>    > - 在HTTP响应报文中的一个cookie首部行,如
>    >
>    >   > ```http
>    >   > Set-cookie: 1678
>    >   > ```
>    >
>    > - 在HTTP请求报文中的一个cookie首部行，如
>    >
>    >   > ```http
>    >   > Cookie: 1678
>    >   > ```
>    >
>    > - 在用户端系统中保留有一个cookie文件，由用户的浏览器进行管理
>    >
>    > - 位于Web站点的一个后端数据库



****

### 2.2.5 Web缓存

> 1. **Web缓存器(Web cache)**
>
>    > - **Web缓存器(Web cache)**也叫**代理服务器(proxy server)**。它能**代表初始Web服务器**来**满足**HTTP**请求的网络实体**。
>    > - Web缓存器有自己的**磁盘存储空间**，并在存储空间中保存最近请求过的**对象**的**副本**。
>    > - 可以配置用户的浏览器，使用户的所有HTTP请求**首先被定向**到该Web缓存器
>
> 2. 被配置首先定向到Web缓存器的用户请求过程：
>
>    > - 浏览器创建一个到**Web缓存器的TCP连接***，并向Web缓存器中的对象发送一个HTPP请求
>    >
>    > - Web缓存器进行检查，看看本地是否存储了该对象的副本，如果有，Web缓存器向客户浏览器用HTTP响应报文返回该对象
>    >
>    > - 如果没有该对象，Web缓存器就**打开一个与该对象的初始服务器的TCP连接**。Web缓存器则在此TCP连接上发送一个对该对象的HTTP请求。在初始服务器收到该请求后，初始服务器向该Web缓存器发送具有该对象的HTTP响应报文
>    >
>    >   > - 虽然没有看过英文版，但我猜这里的*初始服务器*应该是*origin server*，基于此我认为此处翻译成**源服务器**会更好一点，为了不影响后面的笔记，我这边就不改动了。
>    >
>    > - 当Web缓存器接收到该对象时，它在**本地存储空间存储一份副本**，并向客户的浏览器用HTTP响应报文发送该副本(通过客户浏览器和Web缓存器之间的TCP连接)
>
>    值得注意的是，**Web缓存器既是客户也是服务器。**
>
> 3. 配置Web缓存器的**优点**
>
>    > - Web缓存器可以大大**减少**对客户请求的**响应时间**。(高速缓存)
>    > - Web缓存器能够大大**减少**一个机构的**接入链路到因特网的通信量**。(省钱)
>
> 4. **内容分发网络**(Content Distribution Network,**CDN**)
>
>    > - 在因特网上安装了许多地理上分散的缓存器，因而使大量流量实现了本地化





****

### 2.2.6 条件GET方法

> 1. 尽管高速缓存能减少用户感受到的响应时间，但也引入了一个新的问题，即存放在缓存器中的对象副本很可能是过时的。
>
> 2. 条件GET
>
>    > - 请求报文使用GET方法
>    > - 并且请求报文中包含一个`If-Modified-Since:`首部行
>
> 3. 条件GET操作方式：
>
>    > - 首先一个代理缓存器(proxy cache)，向某初始服务器发送一个请求报文：
>    >
>    >   ```http
>    >   GET /fruit/kiwi.gif HTTP/1.1
>    >   Host: www.xxx.com
>    >   ```
>    >
>    > - 其次该初始服务器向缓存器发送具有该请求对象的响应报文：
>    >
>    >   ```http
>    >   HTTP/1.1 200 OK
>    >   Date: Sat, 3 Oct 2015 15:39:29
>    >   Server: Apache/1.3.0 (Unix)
>    >   Last-Modified: Web ,9 Sep 2015 9:23:24
>    >   Content-Type: image/gif
>    >   ....(data)
>    >   ```
>    >
>    > - 该缓存器把对象转发到请求的浏览器时，也在本地缓存了该对象，并且存储了最后修改日期。
>    >
>    > - 一个星期以后，另一个浏览器经过该缓存器请求同一个对象，该对象仍在缓存器中。由于经过了一个礼拜的时间，初始服务器上的对象很可能被修改了，于是该缓存器发送一个条件GET执行检查：
>    >
>    >   ```http
>    >   GET /fruit/kiwi.gif HTTP/1.1
>    >   Host: www.xxx.com
>    >   If-Modified-Since: Web ,9 Sep 2015 9:23:24
>    >   ```
>    >
>    >   `If-Modified-Since:`正好等于一星期前服务器发送的响应报文中的`Last-Modified:`。
>    >
>    > - 服务器执行检查，如果自指定日期之后该对象有被修改过，则重新发送该对象，否则告诉缓存器对象没有被修改过，即发送一个响应报文：
>    >
>    >   ```http
>    >   HTTP/1.1 304 Not Modified
>    >   Date: Sat, 10 Oct 2015 15:39:29
>    >   Server: Apache/1.3.0(Unix)
>    >   (empty entity body)
>    >   ```





****

